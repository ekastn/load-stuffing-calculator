// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: plan.sql

package store

import (
	"context"

	"github.com/google/uuid"
	"github.com/jackc/pgx/v5/pgtype"
)

const addLoadItem = `-- name: AddLoadItem :one
INSERT INTO load_items (
    plan_id,
    item_label,
    length_mm, width_mm, height_mm,
    weight_kg,
    quantity,
    allow_rotation,
    color_hex
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9
)
RETURNING item_id, plan_id, item_label, length_mm, width_mm, height_mm, weight_kg, quantity, allow_rotation, color_hex
`

type AddLoadItemParams struct {
	PlanID        *uuid.UUID     `json:"plan_id"`
	ItemLabel     *string        `json:"item_label"`
	LengthMm      pgtype.Numeric `json:"length_mm"`
	WidthMm       pgtype.Numeric `json:"width_mm"`
	HeightMm      pgtype.Numeric `json:"height_mm"`
	WeightKg      pgtype.Numeric `json:"weight_kg"`
	Quantity      int32          `json:"quantity"`
	AllowRotation *bool          `json:"allow_rotation"`
	ColorHex      *string        `json:"color_hex"`
}

func (q *Queries) AddLoadItem(ctx context.Context, arg AddLoadItemParams) (LoadItem, error) {
	row := q.db.QueryRow(ctx, addLoadItem,
		arg.PlanID,
		arg.ItemLabel,
		arg.LengthMm,
		arg.WidthMm,
		arg.HeightMm,
		arg.WeightKg,
		arg.Quantity,
		arg.AllowRotation,
		arg.ColorHex,
	)
	var i LoadItem
	err := row.Scan(
		&i.ItemID,
		&i.PlanID,
		&i.ItemLabel,
		&i.LengthMm,
		&i.WidthMm,
		&i.HeightMm,
		&i.WeightKg,
		&i.Quantity,
		&i.AllowRotation,
		&i.ColorHex,
	)
	return i, err
}

const createLoadPlan = `-- name: CreateLoadPlan :one
INSERT INTO load_plans (
    plan_code,
    status,
    cont_label,
    length_mm,
    width_mm,
    height_mm,
    max_weight_kg
) VALUES (
    $1, $2, $3, $4, $5, $6, $7
)
RETURNING plan_id, plan_code, status, cont_label, length_mm, width_mm, height_mm, max_weight_kg, created_at
`

type CreateLoadPlanParams struct {
	PlanCode    string         `json:"plan_code"`
	Status      *string        `json:"status"`
	ContLabel   *string        `json:"cont_label"`
	LengthMm    pgtype.Numeric `json:"length_mm"`
	WidthMm     pgtype.Numeric `json:"width_mm"`
	HeightMm    pgtype.Numeric `json:"height_mm"`
	MaxWeightKg pgtype.Numeric `json:"max_weight_kg"`
}

func (q *Queries) CreateLoadPlan(ctx context.Context, arg CreateLoadPlanParams) (LoadPlan, error) {
	row := q.db.QueryRow(ctx, createLoadPlan,
		arg.PlanCode,
		arg.Status,
		arg.ContLabel,
		arg.LengthMm,
		arg.WidthMm,
		arg.HeightMm,
		arg.MaxWeightKg,
	)
	var i LoadPlan
	err := row.Scan(
		&i.PlanID,
		&i.PlanCode,
		&i.Status,
		&i.ContLabel,
		&i.LengthMm,
		&i.WidthMm,
		&i.HeightMm,
		&i.MaxWeightKg,
		&i.CreatedAt,
	)
	return i, err
}

type CreatePlanPlacementParams struct {
	ResultID     *uuid.UUID     `json:"result_id"`
	ItemID       *uuid.UUID     `json:"item_id"`
	PosX         pgtype.Numeric `json:"pos_x"`
	PosY         pgtype.Numeric `json:"pos_y"`
	PosZ         pgtype.Numeric `json:"pos_z"`
	RotationCode *int32         `json:"rotation_code"`
	StepNumber   int32          `json:"step_number"`
}

const createPlanResult = `-- name: CreatePlanResult :one
INSERT INTO plan_results (
    plan_id,
    total_loaded_weight_kg,
    volume_utilization_pct,
    is_feasible
) VALUES (
    $1, $2, $3, $4
)
RETURNING result_id, plan_id, total_loaded_weight_kg, volume_utilization_pct, is_feasible, created_at
`

type CreatePlanResultParams struct {
	PlanID               *uuid.UUID     `json:"plan_id"`
	TotalLoadedWeightKg  pgtype.Numeric `json:"total_loaded_weight_kg"`
	VolumeUtilizationPct pgtype.Numeric `json:"volume_utilization_pct"`
	IsFeasible           *bool          `json:"is_feasible"`
}

func (q *Queries) CreatePlanResult(ctx context.Context, arg CreatePlanResultParams) (PlanResult, error) {
	row := q.db.QueryRow(ctx, createPlanResult,
		arg.PlanID,
		arg.TotalLoadedWeightKg,
		arg.VolumeUtilizationPct,
		arg.IsFeasible,
	)
	var i PlanResult
	err := row.Scan(
		&i.ResultID,
		&i.PlanID,
		&i.TotalLoadedWeightKg,
		&i.VolumeUtilizationPct,
		&i.IsFeasible,
		&i.CreatedAt,
	)
	return i, err
}

const deleteLoadItem = `-- name: DeleteLoadItem :exec
DELETE FROM load_items
WHERE plan_id = $1 AND item_id = $2
`

type DeleteLoadItemParams struct {
	PlanID *uuid.UUID `json:"plan_id"`
	ItemID uuid.UUID  `json:"item_id"`
}

func (q *Queries) DeleteLoadItem(ctx context.Context, arg DeleteLoadItemParams) error {
	_, err := q.db.Exec(ctx, deleteLoadItem, arg.PlanID, arg.ItemID)
	return err
}

const deleteLoadPlan = `-- name: DeleteLoadPlan :exec
DELETE FROM load_plans
WHERE plan_id = $1
`

func (q *Queries) DeleteLoadPlan(ctx context.Context, planID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteLoadPlan, planID)
	return err
}

const deletePlanResults = `-- name: DeletePlanResults :exec
DELETE FROM plan_results WHERE plan_id = $1
`

func (q *Queries) DeletePlanResults(ctx context.Context, planID *uuid.UUID) error {
	_, err := q.db.Exec(ctx, deletePlanResults, planID)
	return err
}

const getLoadItem = `-- name: GetLoadItem :one
SELECT item_id, plan_id, item_label, length_mm, width_mm, height_mm, weight_kg, quantity, allow_rotation, color_hex FROM load_items
WHERE plan_id = $1 AND item_id = $2
`

type GetLoadItemParams struct {
	PlanID *uuid.UUID `json:"plan_id"`
	ItemID uuid.UUID  `json:"item_id"`
}

func (q *Queries) GetLoadItem(ctx context.Context, arg GetLoadItemParams) (LoadItem, error) {
	row := q.db.QueryRow(ctx, getLoadItem, arg.PlanID, arg.ItemID)
	var i LoadItem
	err := row.Scan(
		&i.ItemID,
		&i.PlanID,
		&i.ItemLabel,
		&i.LengthMm,
		&i.WidthMm,
		&i.HeightMm,
		&i.WeightKg,
		&i.Quantity,
		&i.AllowRotation,
		&i.ColorHex,
	)
	return i, err
}

const getLoadPlan = `-- name: GetLoadPlan :one
SELECT plan_id, plan_code, status, cont_label, length_mm, width_mm, height_mm, max_weight_kg, created_at FROM load_plans WHERE plan_id = $1
`

func (q *Queries) GetLoadPlan(ctx context.Context, planID uuid.UUID) (LoadPlan, error) {
	row := q.db.QueryRow(ctx, getLoadPlan, planID)
	var i LoadPlan
	err := row.Scan(
		&i.PlanID,
		&i.PlanCode,
		&i.Status,
		&i.ContLabel,
		&i.LengthMm,
		&i.WidthMm,
		&i.HeightMm,
		&i.MaxWeightKg,
		&i.CreatedAt,
	)
	return i, err
}

const listLoadItems = `-- name: ListLoadItems :many
SELECT item_id, plan_id, item_label, length_mm, width_mm, height_mm, weight_kg, quantity, allow_rotation, color_hex FROM load_items
WHERE plan_id = $1
`

func (q *Queries) ListLoadItems(ctx context.Context, planID *uuid.UUID) ([]LoadItem, error) {
	rows, err := q.db.Query(ctx, listLoadItems, planID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadItem
	for rows.Next() {
		var i LoadItem
		if err := rows.Scan(
			&i.ItemID,
			&i.PlanID,
			&i.ItemLabel,
			&i.LengthMm,
			&i.WidthMm,
			&i.HeightMm,
			&i.WeightKg,
			&i.Quantity,
			&i.AllowRotation,
			&i.ColorHex,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listLoadPlans = `-- name: ListLoadPlans :many
SELECT plan_id, plan_code, status, cont_label, length_mm, width_mm, height_mm, max_weight_kg, created_at FROM load_plans
ORDER BY created_at DESC
LIMIT $1 OFFSET $2
`

type ListLoadPlansParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

func (q *Queries) ListLoadPlans(ctx context.Context, arg ListLoadPlansParams) ([]LoadPlan, error) {
	rows, err := q.db.Query(ctx, listLoadPlans, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []LoadPlan
	for rows.Next() {
		var i LoadPlan
		if err := rows.Scan(
			&i.PlanID,
			&i.PlanCode,
			&i.Status,
			&i.ContLabel,
			&i.LengthMm,
			&i.WidthMm,
			&i.HeightMm,
			&i.MaxWeightKg,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateLoadItem = `-- name: UpdateLoadItem :exec
UPDATE load_items
SET
    item_label = $3,
    length_mm = $4,
    width_mm = $5,
    height_mm = $6,
    weight_kg = $7,
    quantity = $8,
    allow_rotation = $9,
    color_hex = $10
WHERE plan_id = $1 AND item_id = $2
`

type UpdateLoadItemParams struct {
	PlanID        *uuid.UUID     `json:"plan_id"`
	ItemID        uuid.UUID      `json:"item_id"`
	ItemLabel     *string        `json:"item_label"`
	LengthMm      pgtype.Numeric `json:"length_mm"`
	WidthMm       pgtype.Numeric `json:"width_mm"`
	HeightMm      pgtype.Numeric `json:"height_mm"`
	WeightKg      pgtype.Numeric `json:"weight_kg"`
	Quantity      int32          `json:"quantity"`
	AllowRotation *bool          `json:"allow_rotation"`
	ColorHex      *string        `json:"color_hex"`
}

func (q *Queries) UpdateLoadItem(ctx context.Context, arg UpdateLoadItemParams) error {
	_, err := q.db.Exec(ctx, updateLoadItem,
		arg.PlanID,
		arg.ItemID,
		arg.ItemLabel,
		arg.LengthMm,
		arg.WidthMm,
		arg.HeightMm,
		arg.WeightKg,
		arg.Quantity,
		arg.AllowRotation,
		arg.ColorHex,
	)
	return err
}

const updateLoadPlan = `-- name: UpdateLoadPlan :exec
UPDATE load_plans
SET
    plan_code = $2,
    cont_label = $3,
    length_mm = $4,
    width_mm = $5,
    height_mm = $6,
    max_weight_kg = $7,
    status = $8
WHERE plan_id = $1
`

type UpdateLoadPlanParams struct {
	PlanID      uuid.UUID      `json:"plan_id"`
	PlanCode    string         `json:"plan_code"`
	ContLabel   *string        `json:"cont_label"`
	LengthMm    pgtype.Numeric `json:"length_mm"`
	WidthMm     pgtype.Numeric `json:"width_mm"`
	HeightMm    pgtype.Numeric `json:"height_mm"`
	MaxWeightKg pgtype.Numeric `json:"max_weight_kg"`
	Status      *string        `json:"status"`
}

func (q *Queries) UpdateLoadPlan(ctx context.Context, arg UpdateLoadPlanParams) error {
	_, err := q.db.Exec(ctx, updateLoadPlan,
		arg.PlanID,
		arg.PlanCode,
		arg.ContLabel,
		arg.LengthMm,
		arg.WidthMm,
		arg.HeightMm,
		arg.MaxWeightKg,
		arg.Status,
	)
	return err
}

const updatePlanStatus = `-- name: UpdatePlanStatus :exec
UPDATE load_plans
SET status = $2
WHERE plan_id = $1
`

type UpdatePlanStatusParams struct {
	PlanID uuid.UUID `json:"plan_id"`
	Status *string   `json:"status"`
}

func (q *Queries) UpdatePlanStatus(ctx context.Context, arg UpdatePlanStatusParams) error {
	_, err := q.db.Exec(ctx, updatePlanStatus, arg.PlanID, arg.Status)
	return err
}
