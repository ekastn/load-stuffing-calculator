// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: invite.sql

package store

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const acceptInvite = `-- name: AcceptInvite :exec
UPDATE invites
SET accepted_at = NOW()
WHERE invite_id = $1
  AND workspace_id = $2
  AND accepted_at IS NULL
  AND revoked_at IS NULL
`

type AcceptInviteParams struct {
	InviteID    uuid.UUID `json:"invite_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) AcceptInvite(ctx context.Context, arg AcceptInviteParams) error {
	_, err := q.db.Exec(ctx, acceptInvite, arg.InviteID, arg.WorkspaceID)
	return err
}

const createInvite = `-- name: CreateInvite :one
INSERT INTO invites (
    workspace_id,
    email,
    role_id,
    token_hash,
    invited_by_user_id,
    expires_at
) VALUES (
    $1, $2, $3, $4, $5, $6
)
RETURNING invite_id, workspace_id, email, role_id, token_hash, invited_by_user_id, expires_at, accepted_at, revoked_at, created_at
`

type CreateInviteParams struct {
	WorkspaceID     uuid.UUID  `json:"workspace_id"`
	Email           string     `json:"email"`
	RoleID          uuid.UUID  `json:"role_id"`
	TokenHash       string     `json:"token_hash"`
	InvitedByUserID uuid.UUID  `json:"invited_by_user_id"`
	ExpiresAt       *time.Time `json:"expires_at"`
}

func (q *Queries) CreateInvite(ctx context.Context, arg CreateInviteParams) (Invite, error) {
	row := q.db.QueryRow(ctx, createInvite,
		arg.WorkspaceID,
		arg.Email,
		arg.RoleID,
		arg.TokenHash,
		arg.InvitedByUserID,
		arg.ExpiresAt,
	)
	var i Invite
	err := row.Scan(
		&i.InviteID,
		&i.WorkspaceID,
		&i.Email,
		&i.RoleID,
		&i.TokenHash,
		&i.InvitedByUserID,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.RevokedAt,
		&i.CreatedAt,
	)
	return i, err
}

const getInviteByTokenHash = `-- name: GetInviteByTokenHash :one
SELECT invite_id, workspace_id, email, role_id, token_hash, invited_by_user_id, expires_at, accepted_at, revoked_at, created_at
FROM invites
WHERE token_hash = $1
  AND revoked_at IS NULL
  AND accepted_at IS NULL
  AND expires_at > NOW()
`

func (q *Queries) GetInviteByTokenHash(ctx context.Context, tokenHash string) (Invite, error) {
	row := q.db.QueryRow(ctx, getInviteByTokenHash, tokenHash)
	var i Invite
	err := row.Scan(
		&i.InviteID,
		&i.WorkspaceID,
		&i.Email,
		&i.RoleID,
		&i.TokenHash,
		&i.InvitedByUserID,
		&i.ExpiresAt,
		&i.AcceptedAt,
		&i.RevokedAt,
		&i.CreatedAt,
	)
	return i, err
}

const listInvitesByWorkspace = `-- name: ListInvitesByWorkspace :many
SELECT
    i.invite_id,
    i.workspace_id,
    i.email,
    i.role_id,
    r.name AS role_name,
    i.invited_by_user_id,
    u.username AS invited_by_username,
    i.expires_at,
    i.accepted_at,
    i.revoked_at,
    i.created_at
FROM invites i
JOIN roles r ON r.role_id = i.role_id
JOIN users u ON u.user_id = i.invited_by_user_id
WHERE i.workspace_id = $1
ORDER BY i.created_at DESC
LIMIT $2 OFFSET $3
`

type ListInvitesByWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

type ListInvitesByWorkspaceRow struct {
	InviteID          uuid.UUID  `json:"invite_id"`
	WorkspaceID       uuid.UUID  `json:"workspace_id"`
	Email             string     `json:"email"`
	RoleID            uuid.UUID  `json:"role_id"`
	RoleName          string     `json:"role_name"`
	InvitedByUserID   uuid.UUID  `json:"invited_by_user_id"`
	InvitedByUsername string     `json:"invited_by_username"`
	ExpiresAt         *time.Time `json:"expires_at"`
	AcceptedAt        time.Time  `json:"accepted_at"`
	RevokedAt         time.Time  `json:"revoked_at"`
	CreatedAt         time.Time  `json:"created_at"`
}

func (q *Queries) ListInvitesByWorkspace(ctx context.Context, arg ListInvitesByWorkspaceParams) ([]ListInvitesByWorkspaceRow, error) {
	rows, err := q.db.Query(ctx, listInvitesByWorkspace, arg.WorkspaceID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListInvitesByWorkspaceRow
	for rows.Next() {
		var i ListInvitesByWorkspaceRow
		if err := rows.Scan(
			&i.InviteID,
			&i.WorkspaceID,
			&i.Email,
			&i.RoleID,
			&i.RoleName,
			&i.InvitedByUserID,
			&i.InvitedByUsername,
			&i.ExpiresAt,
			&i.AcceptedAt,
			&i.RevokedAt,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const revokeInvite = `-- name: RevokeInvite :exec
UPDATE invites
SET revoked_at = NOW()
WHERE invite_id = $1
  AND workspace_id = $2
  AND accepted_at IS NULL
  AND revoked_at IS NULL
`

type RevokeInviteParams struct {
	InviteID    uuid.UUID `json:"invite_id"`
	WorkspaceID uuid.UUID `json:"workspace_id"`
}

func (q *Queries) RevokeInvite(ctx context.Context, arg RevokeInviteParams) error {
	_, err := q.db.Exec(ctx, revokeInvite, arg.InviteID, arg.WorkspaceID)
	return err
}
