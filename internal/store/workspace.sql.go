// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: workspace.sql

package store

import (
	"context"
	"time"

	"github.com/google/uuid"
)

const createWorkspace = `-- name: CreateWorkspace :one
INSERT INTO workspaces (
    type,
    name,
    owner_user_id
) VALUES (
    $1, $2, $3
)
RETURNING workspace_id, type, name, owner_user_id, created_at, updated_at
`

type CreateWorkspaceParams struct {
	Type        string    `json:"type"`
	Name        string    `json:"name"`
	OwnerUserID uuid.UUID `json:"owner_user_id"`
}

func (q *Queries) CreateWorkspace(ctx context.Context, arg CreateWorkspaceParams) (Workspace, error) {
	row := q.db.QueryRow(ctx, createWorkspace, arg.Type, arg.Name, arg.OwnerUserID)
	var i Workspace
	err := row.Scan(
		&i.WorkspaceID,
		&i.Type,
		&i.Name,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteWorkspace = `-- name: DeleteWorkspace :exec
DELETE FROM workspaces
WHERE workspace_id = $1
`

func (q *Queries) DeleteWorkspace(ctx context.Context, workspaceID uuid.UUID) error {
	_, err := q.db.Exec(ctx, deleteWorkspace, workspaceID)
	return err
}

const getPersonalWorkspaceByOwner = `-- name: GetPersonalWorkspaceByOwner :one
SELECT workspace_id, type, name, owner_user_id, created_at, updated_at
FROM workspaces
WHERE owner_user_id = $1
  AND type = 'personal'
LIMIT 1
`

func (q *Queries) GetPersonalWorkspaceByOwner(ctx context.Context, ownerUserID uuid.UUID) (Workspace, error) {
	row := q.db.QueryRow(ctx, getPersonalWorkspaceByOwner, ownerUserID)
	var i Workspace
	err := row.Scan(
		&i.WorkspaceID,
		&i.Type,
		&i.Name,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getWorkspace = `-- name: GetWorkspace :one
SELECT workspace_id, type, name, owner_user_id, created_at, updated_at
FROM workspaces
WHERE workspace_id = $1
`

func (q *Queries) GetWorkspace(ctx context.Context, workspaceID uuid.UUID) (Workspace, error) {
	row := q.db.QueryRow(ctx, getWorkspace, workspaceID)
	var i Workspace
	err := row.Scan(
		&i.WorkspaceID,
		&i.Type,
		&i.Name,
		&i.OwnerUserID,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listWorkspacesAll = `-- name: ListWorkspacesAll :many
SELECT
    w.workspace_id, w.type, w.name, w.owner_user_id, w.created_at, w.updated_at,
    u.username AS owner_username,
    u.email AS owner_email
FROM workspaces w
JOIN users u ON u.user_id = w.owner_user_id
ORDER BY w.created_at DESC
LIMIT $1 OFFSET $2
`

type ListWorkspacesAllParams struct {
	Limit  int32 `json:"limit"`
	Offset int32 `json:"offset"`
}

type ListWorkspacesAllRow struct {
	WorkspaceID   uuid.UUID `json:"workspace_id"`
	Type          string    `json:"type"`
	Name          string    `json:"name"`
	OwnerUserID   uuid.UUID `json:"owner_user_id"`
	CreatedAt     time.Time `json:"created_at"`
	UpdatedAt     time.Time `json:"updated_at"`
	OwnerUsername string    `json:"owner_username"`
	OwnerEmail    string    `json:"owner_email"`
}

func (q *Queries) ListWorkspacesAll(ctx context.Context, arg ListWorkspacesAllParams) ([]ListWorkspacesAllRow, error) {
	rows, err := q.db.Query(ctx, listWorkspacesAll, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []ListWorkspacesAllRow
	for rows.Next() {
		var i ListWorkspacesAllRow
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.Type,
			&i.Name,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.OwnerUsername,
			&i.OwnerEmail,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspacesByOwner = `-- name: ListWorkspacesByOwner :many
SELECT workspace_id, type, name, owner_user_id, created_at, updated_at
FROM workspaces
WHERE owner_user_id = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListWorkspacesByOwnerParams struct {
	OwnerUserID uuid.UUID `json:"owner_user_id"`
	Limit       int32     `json:"limit"`
	Offset      int32     `json:"offset"`
}

func (q *Queries) ListWorkspacesByOwner(ctx context.Context, arg ListWorkspacesByOwnerParams) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, listWorkspacesByOwner, arg.OwnerUserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workspace
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.Type,
			&i.Name,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listWorkspacesForUser = `-- name: ListWorkspacesForUser :many
SELECT w.workspace_id, w.type, w.name, w.owner_user_id, w.created_at, w.updated_at
FROM workspaces w
JOIN members m ON m.workspace_id = w.workspace_id
WHERE m.user_id = $1
ORDER BY w.created_at DESC
LIMIT $2 OFFSET $3
`

type ListWorkspacesForUserParams struct {
	UserID uuid.UUID `json:"user_id"`
	Limit  int32     `json:"limit"`
	Offset int32     `json:"offset"`
}

func (q *Queries) ListWorkspacesForUser(ctx context.Context, arg ListWorkspacesForUserParams) ([]Workspace, error) {
	rows, err := q.db.Query(ctx, listWorkspacesForUser, arg.UserID, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Workspace
	for rows.Next() {
		var i Workspace
		if err := rows.Scan(
			&i.WorkspaceID,
			&i.Type,
			&i.Name,
			&i.OwnerUserID,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const transferWorkspaceOwnership = `-- name: TransferWorkspaceOwnership :exec
UPDATE workspaces
SET
    owner_user_id = $2,
    updated_at = NOW()
WHERE workspace_id = $1
`

type TransferWorkspaceOwnershipParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	OwnerUserID uuid.UUID `json:"owner_user_id"`
}

func (q *Queries) TransferWorkspaceOwnership(ctx context.Context, arg TransferWorkspaceOwnershipParams) error {
	_, err := q.db.Exec(ctx, transferWorkspaceOwnership, arg.WorkspaceID, arg.OwnerUserID)
	return err
}

const updateWorkspace = `-- name: UpdateWorkspace :exec
UPDATE workspaces
SET
    name = $2,
    updated_at = NOW()
WHERE workspace_id = $1
`

type UpdateWorkspaceParams struct {
	WorkspaceID uuid.UUID `json:"workspace_id"`
	Name        string    `json:"name"`
}

func (q *Queries) UpdateWorkspace(ctx context.Context, arg UpdateWorkspaceParams) error {
	_, err := q.db.Exec(ctx, updateWorkspace, arg.WorkspaceID, arg.Name)
	return err
}
